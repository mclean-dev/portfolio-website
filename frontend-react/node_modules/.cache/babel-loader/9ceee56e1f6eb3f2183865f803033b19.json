{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar assign = require('object-assign');\n\nvar _require = require('../util/observable'),\n    Observable = _require.Observable;\n\nvar polyfilledEventSource = require('@sanity/eventsource');\n\nvar pick = require('../util/pick');\n\nvar defaults = require('../util/defaults');\n\nvar encodeQueryString = require('./encodeQueryString'); // Limit is 16K for a _request_, eg including headers. Have to account for an\n// unknown range of headers, but an average EventSource request from Chrome seems\n// to have around 700 bytes of cruft, so let us account for 1.2K to be \"safe\"\n\n\nvar MAX_URL_LENGTH = 16000 - 1200;\nvar EventSource = polyfilledEventSource;\nvar possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat', 'tag'];\nvar defaultOptions = {\n  includeResult: true\n};\n\nmodule.exports = function listen(query, params) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _this$clientConfig = this.clientConfig,\n      url = _this$clientConfig.url,\n      token = _this$clientConfig.token,\n      withCredentials = _this$clientConfig.withCredentials,\n      requestTagPrefix = _this$clientConfig.requestTagPrefix;\n  var tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join('.') : opts.tag;\n\n  var options = _objectSpread(_objectSpread({}, defaults(opts, defaultOptions)), {}, {\n    tag: tag\n  });\n\n  var listenOpts = pick(options, possibleOptions);\n  var qs = encodeQueryString({\n    query: query,\n    params: params,\n    options: listenOpts,\n    tag: tag\n  });\n  var uri = \"\".concat(url).concat(this.getDataUrl('listen', qs));\n\n  if (uri.length > MAX_URL_LENGTH) {\n    return new Observable(function (observer) {\n      return observer.error(new Error('Query too large for listener'));\n    });\n  }\n\n  var listenFor = options.events ? options.events : ['mutation'];\n  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;\n  var esOptions = {};\n\n  if (token || withCredentials) {\n    esOptions.withCredentials = true;\n  }\n\n  if (token) {\n    esOptions.headers = {\n      Authorization: \"Bearer \".concat(token)\n    };\n  }\n\n  return new Observable(function (observer) {\n    var es = getEventSource();\n    var reconnectTimer;\n    var stopped = false;\n\n    function onError() {\n      if (stopped) {\n        return;\n      }\n\n      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt\n\n      if (stopped) {\n        return;\n      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),\n      // we should never be in a disconnected state. By default, EventSource will reconnect\n      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases\n      // (like when a laptop lid is closed), it closes the connection. In these cases we need\n      // to explicitly reconnect.\n\n\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe();\n        clearTimeout(reconnectTimer);\n        reconnectTimer = setTimeout(open, 100);\n      }\n    }\n\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n\n    function onMessage(evt) {\n      var event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n\n    function onDisconnect(evt) {\n      stopped = true;\n      unsubscribe();\n      observer.complete();\n    }\n\n    function unsubscribe() {\n      es.removeEventListener('error', onError, false);\n      es.removeEventListener('channelError', onChannelError, false);\n      es.removeEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return es.removeEventListener(type, onMessage, false);\n      });\n      es.close();\n    }\n\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({\n          type: 'reconnect'\n        });\n      }\n    }\n\n    function getEventSource() {\n      var evs = new EventSource(uri, esOptions);\n      evs.addEventListener('error', onError, false);\n      evs.addEventListener('channelError', onChannelError, false);\n      evs.addEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return evs.addEventListener(type, onMessage, false);\n      });\n      return evs;\n    }\n\n    function open() {\n      es = getEventSource();\n    }\n\n    function stop() {\n      stopped = true;\n      unsubscribe();\n    }\n\n    return stop;\n  });\n};\n\nfunction parseEvent(event) {\n  try {\n    var data = event.data && JSON.parse(event.data) || {};\n    return assign({\n      type: event.type\n    }, data);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction cooerceError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n\n  var evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\n\nfunction extractErrorMessage(err) {\n  if (!err.error) {\n    return err.message || 'Unknown listener error';\n  }\n\n  if (err.error.description) {\n    return err.error.description;\n  }\n\n  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);\n}","map":{"version":3,"sources":["/home/mcleanj/projects/portfolio-website/frontend-react/node_modules/@sanity/client/lib/data/listen.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","assign","require","_require","Observable","polyfilledEventSource","pick","defaults","encodeQueryString","MAX_URL_LENGTH","EventSource","possibleOptions","defaultOptions","includeResult","module","exports","listen","query","params","opts","undefined","_this$clientConfig","clientConfig","url","token","withCredentials","requestTagPrefix","tag","join","options","listenOpts","qs","uri","concat","getDataUrl","observer","error","Error","listenFor","events","shouldEmitReconnect","indexOf","esOptions","headers","Authorization","es","getEventSource","reconnectTimer","stopped","onError","emitReconnect","readyState","CLOSED","unsubscribe","clearTimeout","setTimeout","open","onChannelError","err","cooerceError","onMessage","evt","event","parseEvent","next","onDisconnect","complete","removeEventListener","type","close","evs","addEventListener","stop","data","JSON","parse","extractErrorMessage","message","description","stringify"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar assign = require('object-assign');\n\nvar _require = require('../util/observable'),\n    Observable = _require.Observable;\n\nvar polyfilledEventSource = require('@sanity/eventsource');\n\nvar pick = require('../util/pick');\n\nvar defaults = require('../util/defaults');\n\nvar encodeQueryString = require('./encodeQueryString'); // Limit is 16K for a _request_, eg including headers. Have to account for an\n// unknown range of headers, but an average EventSource request from Chrome seems\n// to have around 700 bytes of cruft, so let us account for 1.2K to be \"safe\"\n\n\nvar MAX_URL_LENGTH = 16000 - 1200;\nvar EventSource = polyfilledEventSource;\nvar possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat', 'tag'];\nvar defaultOptions = {\n  includeResult: true\n};\n\nmodule.exports = function listen(query, params) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _this$clientConfig = this.clientConfig,\n      url = _this$clientConfig.url,\n      token = _this$clientConfig.token,\n      withCredentials = _this$clientConfig.withCredentials,\n      requestTagPrefix = _this$clientConfig.requestTagPrefix;\n  var tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join('.') : opts.tag;\n\n  var options = _objectSpread(_objectSpread({}, defaults(opts, defaultOptions)), {}, {\n    tag: tag\n  });\n\n  var listenOpts = pick(options, possibleOptions);\n  var qs = encodeQueryString({\n    query: query,\n    params: params,\n    options: listenOpts,\n    tag: tag\n  });\n  var uri = \"\".concat(url).concat(this.getDataUrl('listen', qs));\n\n  if (uri.length > MAX_URL_LENGTH) {\n    return new Observable(function (observer) {\n      return observer.error(new Error('Query too large for listener'));\n    });\n  }\n\n  var listenFor = options.events ? options.events : ['mutation'];\n  var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;\n  var esOptions = {};\n\n  if (token || withCredentials) {\n    esOptions.withCredentials = true;\n  }\n\n  if (token) {\n    esOptions.headers = {\n      Authorization: \"Bearer \".concat(token)\n    };\n  }\n\n  return new Observable(function (observer) {\n    var es = getEventSource();\n    var reconnectTimer;\n    var stopped = false;\n\n    function onError() {\n      if (stopped) {\n        return;\n      }\n\n      emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt\n\n      if (stopped) {\n        return;\n      } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),\n      // we should never be in a disconnected state. By default, EventSource will reconnect\n      // automatically, in which case it sets readyState to `CONNECTING`, but in some cases\n      // (like when a laptop lid is closed), it closes the connection. In these cases we need\n      // to explicitly reconnect.\n\n\n      if (es.readyState === EventSource.CLOSED) {\n        unsubscribe();\n        clearTimeout(reconnectTimer);\n        reconnectTimer = setTimeout(open, 100);\n      }\n    }\n\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n\n    function onMessage(evt) {\n      var event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n\n    function onDisconnect(evt) {\n      stopped = true;\n      unsubscribe();\n      observer.complete();\n    }\n\n    function unsubscribe() {\n      es.removeEventListener('error', onError, false);\n      es.removeEventListener('channelError', onChannelError, false);\n      es.removeEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return es.removeEventListener(type, onMessage, false);\n      });\n      es.close();\n    }\n\n    function emitReconnect() {\n      if (shouldEmitReconnect) {\n        observer.next({\n          type: 'reconnect'\n        });\n      }\n    }\n\n    function getEventSource() {\n      var evs = new EventSource(uri, esOptions);\n      evs.addEventListener('error', onError, false);\n      evs.addEventListener('channelError', onChannelError, false);\n      evs.addEventListener('disconnect', onDisconnect, false);\n      listenFor.forEach(function (type) {\n        return evs.addEventListener(type, onMessage, false);\n      });\n      return evs;\n    }\n\n    function open() {\n      es = getEventSource();\n    }\n\n    function stop() {\n      stopped = true;\n      unsubscribe();\n    }\n\n    return stop;\n  });\n};\n\nfunction parseEvent(event) {\n  try {\n    var data = event.data && JSON.parse(event.data) || {};\n    return assign({\n      type: event.type\n    }, data);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction cooerceError(err) {\n  if (err instanceof Error) {\n    return err;\n  }\n\n  var evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\n\nfunction extractErrorMessage(err) {\n  if (!err.error) {\n    return err.message || 'Unknown listener error';\n  }\n\n  if (err.error.description) {\n    return err.error.description;\n  }\n\n  return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);\n}"]},"metadata":{},"sourceType":"script"}