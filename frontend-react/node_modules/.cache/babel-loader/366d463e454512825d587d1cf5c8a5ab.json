{"ast":null,"code":"\"use strict\";\n/* eslint max-depth: [\"error\", 4] */\n\nvar sameOrigin = require('same-origin');\n\nvar parseHeaders = require('parse-headers');\n\nvar FetchXhr = require('./browser/fetchXhr');\n\nvar noop = function noop() {\n  /* intentional noop */\n};\n\nvar win = typeof window === 'undefined' ? undefined : window;\nvar adapter = win ? 'xhr' : 'fetch';\nvar XmlHttpRequest = typeof XMLHttpRequest === 'function' ? XMLHttpRequest : noop;\nvar hasXhr2 = ('withCredentials' in new XmlHttpRequest()); // eslint-disable-next-line no-undef\n\nvar XDR = typeof XDomainRequest === 'undefined' ? undefined : XDomainRequest;\nvar CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR; // Fallback to fetch-based XHR polyfill for non-browser environments like Workers\n\nif (!win) {\n  XmlHttpRequest = FetchXhr;\n  CrossDomainRequest = FetchXhr;\n}\n\nmodule.exports = function (context, callback) {\n  var opts = context.options;\n  var options = context.applyMiddleware('finalizeOptions', opts);\n  var timers = {}; // Deep-checking window.location because of react native, where `location` doesn't exist\n\n  var cors = win && win.location && !sameOrigin(win.location.href, options.url); // Allow middleware to inject a response, for instance in the case of caching or mocking\n\n  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter: adapter,\n    context: context\n  }); // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n\n  if (injectedResponse) {\n    var cbTimer = setTimeout(callback, 0, null, injectedResponse);\n\n    var cancel = function cancel() {\n      return clearTimeout(cbTimer);\n    };\n\n    return {\n      abort: cancel\n    };\n  } // We'll want to null out the request on success/failure\n\n\n  var xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest();\n  var isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest;\n  var headers = options.headers;\n  var delays = options.timeout; // Request state\n\n  var aborted = false;\n  var loaded = false;\n  var timedOut = false; // Apply event handlers\n\n  xhr.onerror = onError;\n  xhr.ontimeout = onError;\n\n  xhr.onabort = function () {\n    stopTimers(true);\n    aborted = true;\n  }; // IE9 must have onprogress be set to a unique function\n\n\n  xhr.onprogress = function () {\n    /* intentional noop */\n  };\n\n  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';\n\n  xhr[loadEvent] = function () {\n    // Prevent request from timing out\n    resetTimers();\n\n    if (aborted || xhr.readyState !== 4 && !isXdr) {\n      return;\n    } // Will be handled by onError\n\n\n    if (xhr.status === 0) {\n      return;\n    }\n\n    onLoad();\n  }; // @todo two last options to open() is username/password\n\n\n  xhr.open(options.method, options.url, true // Always async\n  ); // Some options need to be applied after open\n\n  xhr.withCredentials = !!options.withCredentials; // Set headers\n\n  if (headers && xhr.setRequestHeader) {\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object');\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer';\n  } // Let middleware know we're about to do a request\n\n\n  context.applyMiddleware('onRequest', {\n    options: options,\n    adapter: adapter,\n    request: xhr,\n    context: context\n  });\n  xhr.send(options.body || null); // Figure out which timeouts to use (if any)\n\n  if (delays) {\n    timers.connect = setTimeout(function () {\n      return timeoutRequest('ETIMEDOUT');\n    }, delays.connect);\n  }\n\n  return {\n    abort: abort\n  };\n\n  function abort() {\n    aborted = true;\n\n    if (xhr) {\n      xhr.abort();\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true;\n    xhr.abort();\n    var error = new Error(code === 'ESOCKETTIMEDOUT' ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url));\n    error.code = code;\n    context.channels.error.publish(error);\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return;\n    }\n\n    stopTimers();\n    timers.socket = setTimeout(function () {\n      return timeoutRequest('ESOCKETTIMEDOUT');\n    }, delays.socket);\n  }\n\n  function stopTimers(force) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || xhr.readyState >= 2 && timers.connect) {\n      clearTimeout(timers.connect);\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket);\n    }\n  }\n\n  function onError(error) {\n    if (loaded) {\n      return;\n    } // Clean up\n\n\n    stopTimers(true);\n    loaded = true;\n    xhr = null; // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n\n    var err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n    err.isNetworkError = true;\n    err.request = options;\n    callback(err);\n  }\n\n  function reduceResponse() {\n    var statusCode = xhr.status;\n    var statusMessage = xhr.statusText;\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200;\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError();\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status;\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    };\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return;\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'));\n      return;\n    } // Prevent being called twice\n\n\n    stopTimers();\n    loaded = true;\n    callback(null, reduceResponse());\n  }\n};","map":{"version":3,"mappings":"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","names":["sameOrigin","require","parseHeaders","FetchXhr","noop","win","window","undefined","adapter","XmlHttpRequest","XMLHttpRequest","hasXhr2","XDR","XDomainRequest","CrossDomainRequest","module","exports","context","callback","opts","options","applyMiddleware","timers","cors","location","href","url","injectedResponse","cbTimer","setTimeout","cancel","clearTimeout","abort","xhr","isXdr","headers","delays","timeout","aborted","loaded","timedOut","onerror","onError","ontimeout","onabort","stopTimers","onprogress","loadEvent","resetTimers","readyState","status","onLoad","open","method","withCredentials","setRequestHeader","key","hasOwnProperty","Error","rawBody","responseType","request","send","body","connect","timeoutRequest","code","error","channels","publish","socket","force","err","isNetworkError","reduceResponse","statusCode","statusMessage","statusText","response","responseText","getAllResponseHeaders"],"sources":["/home/mcleanj/projects/portfolio-website/frontend-react/node_modules/get-it/src/request/browser-request.js"],"sourcesContent":["/* eslint max-depth: [\"error\", 4] */\nconst sameOrigin = require('same-origin')\nconst parseHeaders = require('parse-headers')\nconst FetchXhr = require('./browser/fetchXhr')\n\nconst noop = function() {\n  /* intentional noop */\n}\n\nconst win = typeof window === 'undefined' ? undefined : window\nconst adapter = win ? 'xhr' : 'fetch'\n\nlet XmlHttpRequest = typeof XMLHttpRequest === 'function' ? XMLHttpRequest : noop\nconst hasXhr2 = 'withCredentials' in new XmlHttpRequest()\n// eslint-disable-next-line no-undef\nconst XDR = typeof XDomainRequest === 'undefined' ? undefined : XDomainRequest\nlet CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nif (!win) {\n  XmlHttpRequest = FetchXhr\n  CrossDomainRequest = FetchXhr\n}\n\nmodule.exports = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts)\n  const timers = {}\n\n  // Deep-checking window.location because of react native, where `location` doesn't exist\n  const cors = win && win.location && !sameOrigin(win.location.href, options.url)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest()\n\n  const isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = onError\n  xhr.ontimeout = onError\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  // IE9 must have onprogress be set to a unique function\n  xhr.onprogress = () => {\n    /* intentional noop */\n  }\n\n  const loadEvent = isXdr ? 'onload' : 'onreadystatechange'\n  xhr[loadEvent] = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || (xhr.readyState !== 4 && !isXdr)) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method,\n    options.url,\n    true // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object')\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true\n    xhr.abort()\n    const error = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    xhr = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = error || new Error(`Network error while attempting to reach ${options.url}`)\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse() {\n    let statusCode = xhr.status\n    let statusMessage = xhr.statusText\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError()\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n"]},"metadata":{},"sourceType":"script"}